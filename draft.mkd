% Authenticated Denial of Existence
% Miek Gieben (Technical Advisor SIDN)
% (C\) SIDN 2011.

## Preface
This document tries to answer two simple questions:

> When returning a negative DNSSEC response a nameserver sometimes
> includes up to two NSEC records. With NSEC3 the maximum amount is three.

1. Why do you need up to two NSEC records?
2. And why does NSEC3 sometimes needs an extra record?


## Executive Summary
Authenticated denial of existence is how you communicate to a resolver that a
domain name does not exist in DNSSEC.  It is also used to signal that a domain
name exists, but does not have the specific type you were asking for.

The answer to the questions hinges on the concept of wildcards and the *closest encloser*.
With NSEC, the name that is the *closest encloser* is implicitly given
in the record that also denies the existence of the domain name.  With NSEC3, due
to its hashing, this information has to be given explicitly to a resolver.  It
needs one record to tell the resolver the *closest encloser* and then another to
deny the existence of the domain name.  Both NSEC and NSEC3 may need another
record to deny or assert a wildcard presence at the *clostest encloser* name.

So:

* NSEC needs up to a maximum of two records, and;
* NSEC3 may need up to three.

## Introduction
DNSSEC can be complicated, and there are always corners
of the specification that are even harder to understand.
One such corner is authenticated denial of existence.

Authenticated denial of existence is how you communicate to
a resolver that a domain name does not exist in DNSSEC.
It is also
used to signal that a domain name exists, but does not have the specific type
you were asking for.

The first is called a NXDOMAIN (non-existent domain) and the latter a NODATA
response.

In this document we will try to explain how authenticated denial
of existence works.
We start by explaining the current way of doing things in the DNS
and gradually work our way up to DNSSEC. We explain the first steps
taken in DNSSEC and tell how NXT, NSEC and NSEC3 work. NSEC2 and
DNSNR also briefly make their appearance, as they have paved the
way for NSEC3.

To complete the picture we also need to explain DNS wildcards
as it complicates matters.

Domain names in zone file examples will have a trailing dot, in the
running text they will not.
This text is written for people who have a fair understanding
of DNSSEC. This document currently does not explain NSEC3 opt-out and secure delegations.
This may be added in a future extension.

The following RFCs are not required reading, but they help in
understanding the problem space.

* RFC 5155 - DNS Security (DNSSEC) Hashed Authenticated Denial of Existence;
* RFC 4592 - The Role of Wildcards in the Domain Name System;

These provide general DNSSEC information.

* RFC 4956 - DNS Security (DNSSEC) Opt-In;
* RFC 403{3,4,5} - DNSSEC Specification;
* RFC 3845 - DNS Security (DNSSEC) NextSECure (NSEC) RDATA Format;

And these two drafts give some background information on the NSEC3
development.

* http://tools.ietf.org/html/draft-laurie-dnsext-nsec2v2-00;
* http://tools.ietf.org/html/draft-arends-dnsnr-00.

## NXDOMAIN in the DNS
To explain how it all works we have to start with the basics and look at
NXDOMAIN handling in the DNS. To make it more visible
we are going to use a small DNS zone, with
3 names (`example.org`, `a.example.org` and `d.example.org`) and 3 types (SOA,
A and TXT). For brevity the class is not shown (defaults to IN), the
NS records are left out and the SOA and RRSIG record are shortened. Resulting
in the following unsigned zone file:

    example.org.    SOA ( ... )
    a.example.org.  A   127.0.0.1
                    TXT "a record"
    d.example.org.  A   127.0.0.1
                    TXT "d record"

If a resolver asks for the TXT type belonging to `a.example.org` to the
name server serving this zone, it sends the following question: `a.example.org.TXT`    

The name server looks in its zone data and
generates an answer. In this case a positive one: "Yes it exists
and this is the data", resulting in this reply:

    ;; status: NOERROR, id: 28203

    ;; ANSWER SECTION:
    a.example.org.   TXT    "a record"

    ;; AUTHORITY SECTION:
    example.org.     NS     ns1.example.org.


The `status: NOERROR` signals that everything is OK, `id` is an integer
used to match questions and answers. In the ANSWER section we find
our answer. The AUTHORITY section holds information of which name servers
have information concerning the `example.org` domain.

If a resolver now asks for `b.example.org TXT` it gets an answer that
this name does not exist:

    ;; status: NXDOMAIN, id: 7042

    ;; AUTHORITY SECTION:
    example.org.     SOA     ( ... )

In this case we do not get an ANSWER section and the status
is set to NXDOMAIN. From this the resolver concludes `b.example.org` does not
exist.

## NODATA
It is important to realize, that NXDOMAIN is not the only type
of *does-not-exist*. A name may exist, but the type you are asking
for may not. This occurrence of non-existence is called a `NODATA` response.
Lets ask our name server for `a.example.org AAAA`, and look at the
answer:

    ;; status: NOERROR, id: 7944

    ;; AUTHORITY SECTION:
    example.org.     SOA     ( ... )

The status is `NOERROR` meaning that the `a.example.org` name exists.
But the reply does *not* contain an ANSWER section. Instead it has
an AUTHORITY section which holds the SOA record of `example.org`. The resolver
has to put these pieces of information together and conclude that
`a.example.org` exists, but it does not have an `AAAA` record.


# Secure Denial of Existence
The above must be translated to the security aware world
of DNSSEC. But there are a few things DNSSEC brings to the table:

1. There is no online signing defined in DNSSEC. A
    name server is free to compute the answer and signature(s)
    on-the-fly - PowerDNSSEC does this for instance -
    but the protocol is written with a "first sign", "then load" 
    attitude in mind.
    Thus all denial of existence answers need to pre-computed somehow.
    In the example above you need
    a way to tell somebody who is asking for `b.example.org` that it
    does not exists *without* using the name `b.example.org` in the
    answer. Using the name `b.example.org` in the reply implies
    on-the-fly signing and that is not the DNSSEC way. [^longnote]
    This has been solved by creating a record that
    specifies that something does not exist, so that *this* record can be signed
    beforehand and given to the resolver;

[^longnote]: Given all these troubles why didn't the designers of
DNSSEC went for the (easy) route and allowed for online signing? Well,
at the time (pre 2000), online signing was not feasible with the
current hardware. Keep in mind that the larger servers get
between 2000 and 6000 queries per second (qps), with peaks up to 20,000 qps.
or more.  Scaling signature generation to these kind of levels is
always a challenge. Another issues was (and is) key management, for online
signing to work you need access to the private key(s). This is considered a
security risk.  Off-line signing makes life easier.

2. The DNS packet header is not signed in DNSSEC. 
    This means that a `status: NXDOMAIN` is not signed and
    can not be trusted. In fact the entire header may be forged, including
    the AD bit, which may give some food for thought;

3. DNS wildcards and empty non-terminals complicate matters. More
    about this in later sections.

Because of the first requirement, a zone in DNSSEC must be sorted (put in
canonical ordering as this is called).

> Side note: it is rather asymmetrical, but a lot of the design in DNSSEC
> stem from fact that you need to accommodate authenticated
> denial of existence. If the DNS didn't have NXDOMAIN, DNSSEC would be a
> lot simpler, but a lot less useful!

The road to the current solution (NSEC/NSEC3) was long. In
the beginning there was the NXT (next) record, which was superseded by 
NSEC (next secure) record. From there it went through NSEC2/DNSNR to finally reached
NSEC3 (next secure, version 3) in RFC 5155.


## NXT ##
The first attempt to specify authenticated denial of existence was NXT 
(RFC 2535).  Section 5.1 of that RFC introduces the record:

> The NXT resource record is used to securely indicate that RRs with an
> owner name in a certain name interval do not exist in a zone and to
> indicate what RR types are present for an existing name.

By specifying what you *do* have, you implicitly tell what you *don't* have.

## NSEC ##
In RFC 3755 all the DNSSEC types were given new names, SIG was renamed RRSIG,
KEY became DNSKEY and NXT was simply renamed to NSEC and a few, small 
issues were fixed in the process.

So what does NSEC do?
NSEC is used to describe an interval
between names: it indirectly tells a resolver *which names do not exist* in
a zone.

For this to work we need to the zone to be sorted in canonical ordering
(see RFC 4034, Section 6.1), and
then create the NSECs.
We add three NSEC records, one for each name, and each one "covers" a certain
interval. The last NSEC record points back to the first.

1. The first NSEC covers the interval between `example.org` and
   `a.example.org`;
2. The second NSEC covers: `a.example.org` to `d.example.org`;
3. The third NSEC points back to `example.org`, and covers `d.example.org`
   `example.org` (i.e. the end of the zone).

As we have defined the intervals and put those in resource
records, we now have something that can be signed.
This signed zone is loaded into the name server.

    example.org.        SOA ( ... )
                        DNSKEY ( ... )
                        NSEC a.example.org. SOA NSEC DNSKEY RRSIG
                        RRSIG(SOA) ( ... )
                        RRSIG(DNSKEY) ( ... )
                        RRSIG(NSEC) ( ... )
    a.example.org.      A   127.0.0.1
                        TXT "a record"
                        NSEC b.example.org. A TXT NSEC RRSIG
                        RRSIG(A) ( ... )
                        RRSIG(TXT) ( ... )
                        RRSIG(NSEC) ( ... )
    d.example.org.      A   127.0.0.1
                        TXT "d record"
                        NSEC example.org. A TXT NSEC RRSIG
                        RRSIG(A) ( ... )
                        RRSIG(TXT) ( ... )
                        RRSIG(NSEC) ( ... )

If a DNSSEC aware resolver asks for `b.example.org`, it gets
back a `status: NXDOMAIN` packet, which by itself is meaningless
as the header can be forged. To be able to securely detect that `b` does not exist
there must also be an NSEC record which *covers* the name space
where `b` lives:

    a.example.org. NSEC d.example.org.
    
Does just that, `b`
should come after `a`, but the next owner name is `d.example.org` so
`b` does not exist.

Only by making that calculation, can a resolver conclude that the name
`b` does not exist. If the signature of the NSEC record is valid, `b`
is proven not to exist. We have: *authenticated denial of existence*.

## NODATA Responses
NSEC records are also used in NODATA responses. We need to look more closely 
at the type bitmap. The
type bitmap in an NSEC record tells which types are defined for
a name. If we look at the NSEC record of `a.example.org` we
see the following types in the bitmap: A, TXT, NSEC and RRSIG. So
for the name `a` we must have an A, TXT, NSEC and RRSIG record in the
zone. 

With the type bitmap of the NSEC record a resolver can establish
that a name is there, but the type is not. A resolver
asks for `a.example.org AAAA`. This is the reply that comes
back:

    ;; status: NOERROR, id: 44638

    ;; AUTHORITY SECTION:
    example.org.     SOA        ( ... )
    example.org.     RRSIG(SOA) ( ... )
    a.example.org.   NSEC d.example.org. A TXT NSEC RRSIG
    a.example.org.   RRSIG(NSEC) ( ... )

Now the resolver should check the AUTHORITY section and conclude that (1) `a.example.org`
exist (because of the NSEC with that owner name) and (2) that the type (AAAA) does not
as it is *not* listed in the type bitmap.

By understanding NSEC records you have mastered the basics of
authenticated denial of existence. 

### Issues ####
But there were two issues with NSEC (and NXT).
The first is that allows for zone walking. An NSEC
record points from one name to another, in our example: `example.org`, points
to `a.example.org` which points to `d.example.org` which points back to
`example.org`. So we can reconstruct the entire `example.org` zone even when 
a zone transfer (AXFR) on the servers is denied. Lets see how this would work.

1. First query the `example.org` zone for its NSEC:
   `example.org NSEC`.
    We get an NSEC which has
    the owner name `example.org` and the next owner name `a`. It also lists all
    valid types for the `example.org` name;

2. Using the answer from (1), query for all the record types listed
    in the NSEC record.
    When ready we know everything that is to know for the `example.org` name;

3. Send a new query for the next owner name, in this case `a.example.org`.
    Again we ask for its NSEC:
    `a.example.org. NSEC` and we get back another NSEC to work on. 

4. When we see a name twice we have completed our search and have found all
    the names plus types from the zone. Effectively we have performed 
    a complete zone transfer.
   
The other issue is that when a large, delegation heavy,
zone deploys DNSSEC, every name in the zone would get an NSEC plus
RRSIG. This leads to a huge increase in the zone
size. This would in turn mean that operators of large zones (or with a lot
of zones) deploying DNSSEC face up front costs. This could hinder DNSSEC adoption.

These two issues eventually lead to NSEC3 which:

* Adds a way to garble the next owner name, thus thwarting zone-walking;
* Makes it possible to skip names for the next owner name. This feature
  is called opt-out. It means not all names in your zone get an NSEC3 plus
  ditto signature, making it possible to "grow into" your DNSSEC deployment.

Before we delve in to NSEC3 lets first take a look at its predecessors, NSEC2
and DNSNR.

## NSEC2 and DNSNR ##
NSEC2 was started as a way to solve the two issues
of NSEC. The introduction of the NSEC2 draft has the following paragraph:

> This document proposes an alternate scheme which hides owner names
> while permitting authenticated denial of existence of non-existent
> names.  The scheme uses two new RR types: NSEC2 and EXIST.

When an authenticated denial of existence scheme starts to talk
about EXIST records it is worth paying extra attention.

NSEC2 solved the zone walking, by hashing (with SHA1 and a salt) the
next owner name in the record, thereby making it useless for zone walking.

It did not have opt-out. The proposal
didn't make it because of issues with wildcards and the odd EXISTS
resource record.

The DNSNR was another attempt which used hashed names to
foil zone walking and it introduced the concept of opting out (called
"Authoritative Only Flag") which limited the use of DNSNR in delegation heavy zones.
This proposal didn't make it, but it provided valuable insights into the
problem.

## NSEC3 ##
From the experience gained with NSEC2 and DNSNR, NSEC3 was forged. It incorporates
both opt-out and the hashing of names. NSEC3 solves any issues people might
have with NSEC, but it introduces some additional complexity.

NSEC3 did not supersede NSEC, they are both defined for
DNSSEC. So DNSSEC is blessed with two different means to perform authenticated
denial of existence: NSEC and NSEC3. 

In NSEC3 every name is hashed, including the owner name.

Typically SHA1 is used for
the hashing. To make it even more difficult to retrieve the original names
the hashing can be repeated several times each time taking the previous hash
as input. To thwart rainbow table attacks a custom salt is also added. In the NSEC3
for `example.org` we have hashed the names twice and use the salt `DEAD`.
Lets look a typical NSEC3 record:

    15BG9L6359F5CH23E34DDUA6N1RIHL9H.example.org. NSEC3 1 0 2 DEAD 
            22670TRPLHSR72PQQMEDLTG1KDQEOLB7 NS SOA RRSIG DNSKEY NSEC3PARAM

On the left we see the hashed owner name: `15BG9L6359F5CH23E34DDUA6N1RIHL9H.example.org`, this
is the hashed name of `example.org`. Note that even though we hashed `example.org`, the 
zone's name is always added. So un-hashed it sort of looks like: `SHA1(example.org).example.org`.

The next owner name is hashed to: `22670TRPLHSR72PQQMEDLTG1KDQEOLB7`.
Note that `.example.org` is not added to the next owner name, as this
name always falls in the current zone.

The "1 0 2 DEAD" section of the NSEC3 states: Hash Algorithm = 1 (SHA1), Opt Out = 0 (disabled),
Hash Iterations = 2, Salt = "DEAD". At the end we see the type bit map which is
identical to NSEC's bitmap.

Names like `a.b.c.example.org` hash to one label in NSEC3,
`a.b.c.example.org` becomes: `6LQ07OAHBTOOEU2R9ANI2AT70K5O0RCG.example.org`.

This is an important observation. By hashing the names you loose the depth of
a zone - hashing introduces a flat plain of names.

## Wildcards in the DNS ##
In the above sections we haven't told the whole story. There is a complication: wildards.
Wildcards have been part of the DNS since the first DNS RFCs. They allow to define
*all* names for a certain type in one go. In our `example.org` zone we could for instance
include a record:

    *.example.org.   TXT "wildcard record"

<!-- * keep vim's syntax happy --> If a resolver asks for for `z.example.org TXT`, 
the name server will respond with an *expanded wildcard*, instead of an NXDOMAIN:

    ;; status: NOERROR, id: 13658

    ;; ANSWER SECTION:
    z.example.org.   TXT "wildcard record"
    
Note however that the resolver can not see that this answer came from a wildcard. It just
sees the answer as-is. How will this answer look with DNSSEC [^longnote2]?

    ;; status: NOERROR, id: 51790

    ;; ANSWER SECTION:
    z.example.org.    TXT    "wildcard record"
    z.example.org.    RRSIG(TXT) ( ... )

    ;; AUTHORITY SECTION:
    d.example.org.    NSEC example.org. A TXT RRSIG NSEC
    d.example.org.    RRSIG(NSEC) ( ... )

[^longnote2]: An astute reader may notice that it appears as if a `z.example.org` `RRSIG` is created
out of thin air. This is not the case. The signature for `z.example.org` does not exist.
The signature you are seeing is the one for `*.example.org` which does exist, only 
the owner name is switched to `z.example.org`. So even
with wildcards, no signatures are created on the fly.

The NSEC tells there is a wildcard configured in this zone. How? The
interval `d` .. `start of zone` does not included the wildcard hence
it should exist.
One thing you should notice is that this reply has an NSEC record in it *even* though
it is not an NXDOMAIN nor NODATA reply. In this case it is there to tell the resolver
this answer was synthesized from a wildcard. 

From the reply above we see that `z.example.org` should exist. If the NSEC was not
included in the response an attacker
could, with some careful tweaking, modify the packet in such ways that it says
`z.example.org` does *not* exists.

The tweaking consists of setting the status
to NXDOMAIN, including the correct RRs (SOA and RRSIG(SOA)) in the AUTHORITY section
and removing the ANSWER section, resulting in:

    ;; status: NXDOMAIN, id: 51790

    ;; AUTHORITY SECTION:
    example.org.    SOA ( ... )
    example.org.    RRSIG(SOA) ( ... )

Which is a perfectly valid answer. So if DNSSEC does not tell that a resolver
should look for an NSEC that says something about wildcards, we can
spoof a resolver into believing that a name does not exist,
while in fact it does. This is bad and defeats all the security DNSSEC
can deliver. 

A resolver can detect such a spoofing attempt:

1. If the NSEC is not present, assume the answer is spoofed;
2. If the NSEC is there, check it. If the signature is not correct,
   assume a spoofed answer.

An another way of putting this is that DNSSEC is there to ensure
the name server has followed the steps as outlined in RFC 1034 Section 4.3.2
for looking up names in the zone. 
It explicitly lists wildcard lookup as on of these steps (3c), so with DNSSEC this must be
communicated to the resolver: hence the NSEC record.

With NSEC the maximum number of NSEC records a resolver can get back is
two: one for the negative answer and another for the wildcard.
We say maximum, because sometimes a single NSEC can prove multiple
things.  With NSEC3 it is three, as we will try to explain in the next 
section.

## Returning Three NSEC3s
With NSEC3 matters are more complicated. Because of the wildcard NSEC3, you 
need another piece of information. So we have the denial of existence NSEC3,
the wildcard NSEC3 and the NSEC3 that tells us the rest. So why do we to know
even more?

The short answer is that due to the hashing in NSEC3 you loose the depth
of your zone: everything is hashed into a flat plain. To make up for this
loss of information you need an extra record.
The more detailed answer is quite a bit longer.

To understand NSEC3 we will need two definitions:

Closest encloser

:   Introduced in RFC 4592, this is the first *existing* name in the zone that is an ancestor of
    the name used in the query. Suppose the query name is `2.example.org`
    then `example.org` is the *closest encloser*.

Next closer name

:   Introduced in the NSEC3 RFC, this is the closest encloser with one more label added to the left.
    So if `example.org` is the closest encloser, `3.example.org` might be the *next closer name*.

An NSEC3 *proof* consists of:

1. An NSEC3 RR that **matches** the *closest encloser*. This means the
   un-hashed owner name of the record *is* the closest encloser. This bit of
   information tells a resolver: "The name you are asking for does 
   not exists, the closest I have is this". 

2. An NSEC3 RR that **covers** the *next closer name*. This means it
   defines an interval in which the *next closer name* falls. This
   tells the resolver: "The name in your question falls in
   this interval, and therefor it does not exist". 

Take the following example. We have our zone, but now with the following
two records and it is signed with NSEC3.

    1.1.example.org.        TXT "1.1 record"
    3.3.example.org         TXT "3.3 record"

These records are empty non terminals, but that is not important for this
explanation. 

The resolver asks the following: `x.2.example.org TXT`.
This leads to an NXDOMAIN response from the server, which contains
two NSEC3 records:

    15BG9L6359F5CH23E34DDUA6N1RIHL9H.example.org. 
        NSEC3 1 0 2 DEAD 3GM0KCUB31AM5C8R6SKFK1DKIE7HP1PB NS SOA RRSIG 
                                                          DNSKEY NSEC3PARAM

    75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ.example.org. 
        NSEC3 1 0 2 DEAD 8555T7QEGAU7PJTKSNBCHG4TD2M0JNPJ

The resolver is interested in one thing:

> Does the hash of `x.2.example.org` fall in any of the intervals of 
> the NSEC3 records it got?

The hash of `x.2.example.org` is `NDTU6DSTE50PR4A1F2QVR1V31G00I2I1`.
Checking this hash on the first NSEC3 yields that it does not fall
in between the interval: `15BG9L6359F5CH23E34DDUA6N1RIHL9H` and `75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ`.

For the second NSEC3 the answer is also negative: the hash sorts outside
the interval described. What is a resolver to do? It has been given two NSEC3 and both seem useless.

Another question you might have at this points could be, why doesn't server just send the
NSEC3 that does cover the hash of `x.2.example.org`? It can not do this due to the fact that it must
also communicate for which name there is, or is not, a wildcard presence. From the resolver's
point of view, there could be a wildcard at `*.2.example.org`, `*.example.org`, `*.org` or none
of the above. Where is it?

This is where the closest encloser proof comes into play.
It proofs there is some existing ancestor: there must exist something shorter
than the query that exists in the zone. This is the *closest encloser*.

And there is another name, that is one label longer than the
closest encloser, that does should not exist. The label that gets added comes
from the query name. This is the *next closer name*.

So in our case the resolver must first detect the NSEC3 that
matches the closest encloser. It does this by chopping up the query name,
hashing each instance (with the same number of iterations and hash
as the zone it is querying) and comparing that to the answers
given. So it has the following hashes to work with:

* `x.2.example.org`: `NDTU6DSTE50PR4A1F2QVR1V31G00I2I1`;
* `2.example.org`: `7T70DRG4EKC28V93Q7GNBLEOPA7VLP6Q`;
* `example.org`: `15BG9L6359F5CH23E34DDUA6N1RIHL9H`;
* `org`: `B7ID5C04KP39ULGGCNJQ2MJ36ABG4F0C`.

Of these hashes only one matches the owner name of one of the NSEC3
records: `15BG9L6359F5CH23E34DDUA6N1RIHL9H`. This is the closest
encloser (un-hashed: `example.org`). That's the most important purpose of that NSEC3 record:
tell the resolver what the closest encloser is. (The other reason has to do
with the type bitmap and DNAMEs: a topic for another installment.)

From that knowledge the resolver constructs the 'next closer', which
in this case is: `2.example.org`. The hash of *this* name should be
covered in the other NSEC3. And it is, `7T70DRG4EKC28V93Q7GNBLEOPA7VLP6Q` falls in the interval
set by: `75B9ID679QQOV6LDFHD8OCSHSSSB6JVQ` and `8555T7QEGAU7PJTKSNBCHG4TD2M0JNPJ`.

So what does the resolver learn from this?

1. `example.org` exists;
2. `2.example.org` does *not* exist.

And if `2.example.org` does not exist, `x.2.example.org` also does not exist.
We have validated the answer and have reached our goal: authenticated denial
of existence.

> Yes, the resolver also needs to check `*.example.org` to be fully compliant
> with the specification.

Coming back to the original question: why do we need (up to) three NSEC3
records? The resolver need to be explicitly told what the *closest encloser* is
and this takes up a full NSEC3 record. With that knowledge it can make sense
of the other NSEC3 records and get the proof it needs to assert secure
denial of existence.

# Acknowledgements
This document was not possible without the help of Ed Lewis, Roy Arends, Wouter
Wijngaards, Mathijs Mekking, Marco Davids, Esther Makaay and Antoin Verschuren.
Also valuable was the source code of Unbound (`validator/val_nsec3.c`).

# Appendix

## Slaving an NSEC3 Zone
A secondary servers slaving a zone with NSEC3 records need to find
out the specifics (hash iterations and salt) to be able to generate
its own NSEC3 records.

To do this IT could scan the zone during the AXFR for NSEC3
records and glance the NSEC3 parameters from them. But it was decided
that a more reliable way was needed, i.e. the server can look at
one record at a static place and see directly the NSEC3 parameters
used.

The solution was to create a record: NSEC3PARAM. Which must be placed at the
apex of the zone.  Its sole role is to provide information about the NSEC3
parameters to secondary name servers.  Was NSEC3 designed on the early days of
DNS (+/- 1985) this information was probably put in the SOA record.
